/*
 * stm32f407xx_gpio.c
 *
 *  Created on: Apr 12, 2025
 *      Author: nhduong
 */

#include "stm32f407xx_gpio.h"

/**
 * @brief  Enables or disables the clock for the specified GPIO peripheral.
 * @param  pGPIOx: Pointer to GPIO peripheral base address (e.g., GPIOA, GPIOB).
 * @param  State: ENABLE or DISABLE.
 * @retval None
 */
void GPIO_ClockControl(GPIO_TypeDef *pGPIOx, uint8_t State)
{
    if(State == ENABLE)
    {
        if(pGPIOx == GPIOA) { GPIOA_CLK_EN(); }
        else if (pGPIOx == GPIOB) { GPIOB_CLK_EN(); }
        else if (pGPIOx == GPIOC) { GPIOC_CLK_EN(); }
        else if (pGPIOx == GPIOD) { GPIOD_CLK_EN(); }
        else if (pGPIOx == GPIOE) { GPIOE_CLK_EN(); }
        else if (pGPIOx == GPIOF) { GPIOF_CLK_EN(); }
        else if (pGPIOx == GPIOG) { GPIOG_CLK_EN(); }
        else if (pGPIOx == GPIOH) { GPIOH_CLK_EN(); }
        else if (pGPIOx == GPIOI) { GPIOI_CLK_EN(); }
    }
    else
    {
        if(pGPIOx == GPIOA) { GPIOA_CLK_DIS(); }
        else if (pGPIOx == GPIOB) { GPIOB_CLK_DIS(); }
        else if (pGPIOx == GPIOC) { GPIOC_CLK_DIS(); }
        else if (pGPIOx == GPIOD) { GPIOD_CLK_DIS(); }
        else if (pGPIOx == GPIOE) { GPIOE_CLK_DIS(); }
        else if (pGPIOx == GPIOF) { GPIOF_CLK_DIS(); }
        else if (pGPIOx == GPIOG) { GPIOG_CLK_DIS(); }
        else if (pGPIOx == GPIOH) { GPIOH_CLK_DIS(); }
        else if (pGPIOx == GPIOI) { GPIOI_CLK_DIS(); }
    }
}


/**
 * @brief  Initializes the GPIOx peripheral according to the specified parameters in the GPIO_Init.
 * @param  hGPIO: Pointer to a GPIO_Handle_t structure that contains
 *         the configuration information for the specified GPIO peripheral.
 * @retval None
 */
void GPIO_Init(GPIO_HandleTypeDef *hGPIO)
{
	uint32_t tempreg = 0;

	// Enable the GPIO clock for the specific GPIO port
	GPIO_ClockControl(hGPIO->pGPIOx, ENABLE);

	// Step 1: Configure the mode of the GPIO pin
	if (hGPIO->Init.Mode <= GPIO_MODE_ANALOG)
	{
		// the non interrupt mode
		tempreg = (hGPIO->Init.Mode << (2 * hGPIO->Init.Pin));
		hGPIO->pGPIOx->MODER &= ~(0x3 << (2 * hGPIO->Init.Pin));
		hGPIO->pGPIOx->MODER |= temp;
	}else {
		// the interrupt mode
		if (hGPIO->Init.Mode == GPIO_MODE_IT_FALLING)
		{
			// Configure the FTSR
			EXTI->FTSR |= (1 << hGPIO->Init.Pin);

			// Clear the corresponding the RTSR
			EXTI->RTSR &= ~(1 << hGPIO->Init.Pin);
		}else if (hGPIO->Init.Mode = GPIO_MODE_IT_RISING)
		{
			// Configure the RTSR
			EXTI->RTSR |= (1 << hGPIO->Init.Pin);

			// Clear the corresponding the FTSR
			EXTI->FTSR |= (1 << hGPIO->Init.Pin);
		}else {
			// Configure both FTSR and RTSR
			EXTI->FTSR |= (1 << hGPIO->Init.Pin);

			EXTI->RTSR |= (1 << hGPIO->Init.Pin);
		}
		// Configure the GPIO port selection in SYSCFG_EXTICR
		uint32_t temp1 = hGPIO->Init.Pin / 4;
		uint32_t temp2 = hGPIO->Init.Pin % 4;
		uint8_t portCode = GPIO_PORTCODE(hGPIO->pGPIOx);
		SYSCFG_CLK_EN();
	}

}
void GPIO_DeInit(GPIO_RegDef_t *pGPIOx);

/*
 * Data read and write
 */
uint8_t GPIO_ReadPin(GPIO_RegDef_t *pGPIOx, uint8_t GPIO_Pin);
uint16_t GPIO_ReadPort(GPIO_RegDef_t *pGPIOx);
void GPIO_WritePin(GPIO_RegDef_t *pGPIOx, uint8_t GPIO_Pin, uint8_t Value);
void GPIO_WritePort(GPIO_RegDef_t *pGPIOx, uint16_t Value);
void GPIO_TogglePin(GPIO_RegDef_t *pGPIOx, uint8_t GPIO_Pin);

/*
 * IRQ Configuration and ISR handling
 */
void GPIO_IRQInterruptConfig(uint8_t IRQNumber, uint8_t State);
void GPIO_IRQPriorityConfig(uint8_t IRQNumber, uint32_t IRQPriority);
void GPIO_IRQHandler(uint8_t GPIO_Pin);

