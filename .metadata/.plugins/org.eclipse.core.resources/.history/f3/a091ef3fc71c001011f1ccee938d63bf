/*
 * stm32f407xx_spi.c
 *
 *  Created on: Apr 17, 2025
 *      Author: nhduong
 */

#include "stm32f407xx_spi.h"

/**
 * @brief  Enables or disables the clock for the specified SPIx peripheral.
 *
 * @param  pGPIOx where x can be (1,2 or 3) to select the SPI peripheral
 *
 * @param  State: ENABLE or DISABLE.
 *
 * @retval None
 */
void SPI_PeriClockControl(SPI_TypeDef *pSPIx, uint8_t State)
{
	if (State == ENABLE)
	{
		if (pSPIx == SPI1)
		{
			SPI1_CLK_EN();
		}else if (pSPIx == SPI2)
		{
			SPI2_CLK_EN();
		}else {
			SPI3_CLK_EN();
		}
	}else {
		if (pSPIx == SPI1)
		{
			SPI1_CLK_DIS();
		}else if (pSPIx == SPI2)
		{
			SPI2_CLK_DIS();
		}else {
			SPI3_CLK_DIS();
		}
	}
}
/**
  * @brief  Initialize the SPI according to the specified parameters
  *         in the SPI_InitTypeDef and initialize the associated handle.
  *
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  *
  * @retval None
  */
void SPI_Init(SPI_HandleTypeDef *hspi)
{
	uint32_t tempreg = 0;

	// 1. Enable the SPI peripheral clock
	SPI_PeriClockControl(hspi->pSPIx, ENABLE);

	// 2. Disable the SPI peripheral before configuring it
	hspi->pSPIx->CR1 &= ~(1 << SPI_CR1_SPE);

	// 3. Configure device mode (Master/Slave)
	tempreg |= hspi->Init.Mode << SPI_CR1_MSTR;

	// 4. Configure bus configuration (Full-Duplex, Half-Duplex, or Simplex RX-only)
	if (hspi->Init.Direction == SPI_DIRECTION_FULLDUPLEX)
	{
		// Clear BIDIMODE for full-duplex
		tempreg &= ~(1 << SPI_CR1_BIDIMODE);
	}
	else if (hspi->Init.Direction == SPI_DIRECTION_HALFDUPLEX)
	{
		// Set BIDIMODE for half-duplex
		tempreg |= (1 << SPI_CR1_BIDIMODE);
	}
	else // SPI_DIRECTION_SIMPLEX_RXONLY
	{
		// Clear BIDIMODE and set RXONLY for simplex RX-only
		tempreg &= ~(1 << SPI_CR1_BIDIMODE);
		tempreg |= (1 << SPI_CR1_RXONLY);
	}

	// 5. Set the Baud Rate Prescaler
	tempreg |= hspi->Init.BaudRatePrescaler << SPI_CR1_BR;

	// 6. Configure Data Frame Format (8-bit or 16-bit)
	tempreg |= hspi->Init.DataSize << SPI_CR1_DFF;

	// 7. Set Clock Polarity (CPOL)
	tempreg |= hspi->Init.CLKPolarity << SPI_CR1_CPOL;

	// 8. Set Clock Phase (CPHA)
	tempreg |= hspi->Init.CLKPhase << SPI_CR1_CPHA;

	// 9. Configure NSS management (Software or Hardware)
	if (hspi->Init.NSS == SPI_NSS_SOFT)
	{
		// Enable Software Slave Management
		tempreg |= (1 << SPI_CR1_SSM);

		// Set SSI bit to avoid MODF error when SSM is enabled
		tempreg |= (1 << SPI_CR1_SSI);
	}
	else // SPI_NSS_HARD
	{
		// Disable Software Slave Management
		tempreg &= ~(1 << SPI_CR1_SSM);

		// Enable NSS output (SSOE = 1) in CR2 for master hardware mode
		hspi->pSPIx->CR2 |= (1 << SPI_CR2_SSOE);
	}

	// 10. Write final configuration to CR1 register
	hspi->pSPIx->CR1 = tempreg;

	// 11. Enable SPI peripheral
	hspi->pSPIx->CR1 |= (1 << SPI_CR1_SPE);
}


/**
  * @brief  De-Initialize the SPI peripheral.
  *
  * @param  pSPIx pointer to a SPI_TypeDef structure that contains
  *               the configuration information for SPI module.
  *
  * @retval None
  */
void SPI_DeInit(SPI_TypeDef *pSPIx)
{
	if (pSPIx == SPI1)
	{
		SPI1_REG_RESET();
	}else if (pSPIx == SPI2)
	{
		SPI2_REG_RESET();
	}else if (pSPIx == SPI3)
	{
		SPI3_REG_RESET();
	}
}

/**
  * @brief  Transmit an amount of data in blocking mode.
  *
  * @param  pSPIx pointer to SPI peripheral (e.g., SPI1, SPI2, SPI3).
  *
  * @param  pData pointer to data buffer (uint8_t or uint16_t).
  *
  * @param  Len number of data elements to be sent.
  *
  * @retval None
  */
void SPI_Transmit(SPI_TypeDef *pSPIx, uint8_t *pData, uint32_t Len)
{
	while (Len > 0)
	{
		// Wait until TXE (Transmit buffer empty) flag is set
		while(SPI_GetFlag(pSPIx, SPI_FLAG_TXE) == FLAG_RESET);

		// Check the DFF (Data Frame Format) bit in CR1 to determine data size
		if ((pSPIx->CR1 & (1 << SPI_CR1_DFF)))
		{
			// 16-bit data format
			// Load 2 bytes (uint16_t) into the data register
			pSPIx->DR = *((uint16_t*)pData);

			// Decrease length by 2 and move data pointer by 2
			Len -= 2;
			pData += 2;
		}
		else
		{
			// 8-bit data format
			// Load 1 byte (uint8_t) into the data register
			pSPIx->DR = *pData;

			// Decrease length by 1 and move data pointer by 1
			Len--;
			pData++;
		}
	}

	// Wait until BSY (Busy flag) is reset, to make sure SPI is done transmitting
	while(SPI_GetFlag(pSPIx, SPI_FLAG_BSY));
}

/**
  * @brief  Receive an amount of data in blocking mode.
  *
  * @param  pSPIx pointer to SPI peripheral (e.g., SPI1, SPI2, SPI3)
  *
  * @param  pRxBuffer pointer to data buffer (uint8_t or uint16_t) to store received data.
  *
  * @param  Len number of data elements to be received.
  *
  * @retval None
  */
void SPI_Receive(SPI_TypeDef *pSPIx, uint8_t *pRxBuffer, uint32_t Len)
{
	while (Len > 0)
	{
		// Wait until RXNE (Receive buffer not empty) flag is set
		while(SPI_GetFlag(pSPIx, SPI_FLAG_RXNE) == FLAG_RESET);

		// Check the DFF (Data Frame Format) bit in CR1 to determine data size
		if ((pSPIx->CR1 & (1 << SPI_CR1_DFF)))
		{
			// 16-bit data format
			// Read 2 bytes (uint16_t) from data register into receive buffer
			*((uint16_t*)pRxBuffer) = pSPIx->DR;

			// Decrease length by 2 and move buffer pointer forward by 2
			Len -= 2;
			pRxBuffer += 2;
		}
		else
		{
			// 8-bit data format
			// Read 1 byte (uint8_t) from data register into receive buffer
			*pRxBuffer = pSPIx->DR;

			// Decrease length by 1 and move buffer pointer forward by 1
			Len--;
			pRxBuffer++;
		}
	}

	// Wait until BSY (Busy flag) is reset, to ensure SPI is not busy
	while(SPI_GetFlag(pSPIx, SPI_FLAG_BSY));
}

/**
  * @brief  Transmit an amount of data in non-blocking mode with Interrupt.
  *
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  *
  * @param  pData pointer to data buffer (u8 or u16 data elements)
  *
  * @param  Len amount of data elements to be sent
  *
  * @retval SPI state
  */
uint8_t SPI_Transmit_IT(SPI_HandleTypeDef *hspi,uint8_t *pData, uint32_t Len)
{
	uint8_t State = hspi->TxState
}
uint8_t SPI_Receive_IT(SPI_HandleTypeDef *hspi, uint8_t *pData, uint32_t Len);

/*
 * IRQ Configuration and ISR handling
 */
void SPI_IRQInterruptConfig(uint8_t IRQNumber, uint8_t State);
void SPI_IRQPriorityConfig(uint8_t IRQNumber, uint32_t IRQPriority);
void SPI_IRQHandler(SPI_HandleTypeDef *hspi);

/*
 * Other Peripheral Control APIs
 */
uint8_t SPI_GetFlag(SPI_TypeDef *pSPIx , uint32_t FlagName);
void SPI_ClearOVRFlag(SPI_TypeDef *pSPIx);
void SPI_CloseTx(SPI_HandleTypeDef *hspi);
void SPI_CloseRx(SPI_HandleTypeDef *hspi);

/*
 * Application callback
 */
void SPI_ApplicationEventCallback(SPI_HandleTypeDef *hspi, uint8_t AppEv);








